---
marp: true
theme: gaia
---

# マルチスレッドカウンター

### – 性能と正確性の探求 –

発表者：toutou
\<br\>
\<br\>
\<small\>実行環境: 24 論理プロセッサ\</small\>

-----

## 1\. 問題提起：メソッド呼び出しを数えたい！

高トラフィックな環境で、メソッドの呼び出し回数を記録したい！
シンプルな`Dictionary`で実装してみると...

```csharp:methodcounter_notthreadsafe.cs
public class MethodCounter_NotThreadSafe : IMethodCounter
{
    private Dictionary<string, int> _counts = new();

    public void Record(string methodName)
    {
        if (_counts.ContainsKey(methodName))
            _counts[methodName]++;  // ← 危険！
        else
            _counts[methodName] = 1;
    }
}
```

**複数のスレッドから同時にアクセスすると、どうなるでしょう？**

-----

## 1\. ...そしてデータが壊れる 💥

100スレッドで合計100万回呼び出すと、カウントが全く合わなくなります。

```console:実行結果
## 1. スレッドセーフでない実装の問題点
--------------------------------------------------
  -> 期待したカウント: 1,000,000
  -> 実際のカウント:   112,644
  -> 例外の発生回数:   0

  [結論] この実装はマルチスレッド環境では全く信頼できません。
```

  * **データ不整合**: `++`の処理はアトミックではないため、更新が失われる。
  * **例外発生**: 今回は発生しませんでしたが、`Dictionary`の内部構造が壊れてクラッシュすることもあります。

-----

## 2\. 解決策：`lock`で守る

`lock`ステートメントで処理を囲むことで、一度に一つのスレッドしかコードブロックを実行できないようにします（**相互排他**）。

```csharp:methodcounter_withlock.cs
public class MethodCounter_WithLock : IMethodCounter
{
    private readonly object _lock = new();

    public void Record(string methodName)
    {
        lock (_lock) // このブロックは一度に一つのスレッドのみ
        {
            if (_counts.ContainsKey(methodName))
                _counts[methodName]++;
            else
                _counts[methodName] = 1;
        }
    }
}
```

**これにより、処理は安全になります。**

-----

## 2\. `lock`で得られる「安心感」

同じテストを実行すると、今度は期待通りの正確な結果になります。

```console:実行結果
## 2. 'lock'によるスレッドセーフな実装
--------------------------------------------------
  -> 期待したカウント: 1,000,000
  -> 実際のカウント:   1,000,000

  [結論] 'lock'を使えば、安全で正確なカウンターを簡単に実装できます。
```

**問題解決！...でも、性能は大丈夫？**
スレッドの「順番待ち」がボトルネックになるのでは？

-----

## 3\. 性能比較：Lock vs Lock-Free

`lock`の性能問題を解決するため、`ConcurrentQueue<T>`を使った**Lock-Free実装**を試します。

```console:実行結果
## 3. パフォーマンスとLock-Free版の登場
--------------------------------------------------
  -> ✅ Lock版:           9,146,396 件/秒
  -> ⚡ Lock-free版:      14,775,923 件/秒

  [結論] Lock-Free版はLock版の約1.62倍、高速に書き込みが可能です！
```

**これで速度も正確性も完璧...でしょうか？**

-----

## 4\. Lock-Free版の落とし穴

高速なLock-Free版ですが、**書き込みと読み出しを同時に**行う高負荷テストを実行すると...

```console:実行結果
## 4. Lock-Free版の落とし穴：データロスト
--------------------------------------------------
  -> 書き込み総数: 151,192,646
  -> 読み取り総数: 151,192,644
  -> ロストした数: 2

  [結論] わずかですが、データがロストしてしまいました！
```

**なぜ高速化と引き換えに、データが失われるのでしょうか？**

-----

## 5\. なぜ？データロストのメカニズム

原因は、ナノ秒単位で発生する**競合状態 (Race Condition)** です。

| 時間 | 書込スレッドA (`Record`) | 読出スレッドB (`GetCountsAndReset`) |
| :-- | :--- | :--- |
| t1 | `_events.Enqueue`を実行しようと、現在のキュー(**Queue1**)の参照を掴む | (待機中) |
| t2 | **(ここでスレッド切替！) →** | (待機中) |
| t3 | (待機中) | `Interlocked.Exchange`を実行。`_events`は新品の**Queue2**に差し替わる。読出スレッドは古い**Queue1**を集計対象として受け取る。 |
| t4 | **(ここでスレッド切替！) →** | (集計処理中) |
| t5 | 処理再開。**掴んでいた古い`Queue1`の参照に対して**`Enqueue`を実行！ | (集計処理中) |

`_events`の参照は`Queue2`に変わっているのに、スレッドAは古い`Queue1`に書き込んでしまう。
**そのデータは誰にも読まれず、永遠に失われます。**

-----

## まとめ

| 実装 | 正確性 | 性能 | 特徴 |
|:--- |:---:|:---:|:--- |
| **NotThreadSafe** | ❌ | ? | 論外。使ってはいけない。 |
| **WithLock** | ✅ | ⚠️ | **安全・確実**。正確性が最優先の場合の第一選択。性能ボトルネックの可能性あり。|
| **LockFree** | ⚠️ | ✅ | **超高速**。多少の誤差を許容できるアクセス解析やログ収集などで強力。|

> **「最高の解決策」は存在しない。**
> **性能と正確性のトレードオフを理解し、要件に合った最適な道具を選ぶことが重要。**

ご清聴ありがとうございました。