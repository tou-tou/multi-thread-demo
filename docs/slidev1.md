# 「パフォーマンスか正確性か？～実践的マルチスレッド設計の勘所～」

## スライド1: タイトル（20秒）

**パフォーマンスか正確性か？**  
**～実践的マルチスレッド設計の勘所～**

メソッドカウンターの実装から学ぶ、高負荷システムでの設計判断

発表者: [Your Name]

---

## スライド2: 本日のお題（30秒）

### 高頻度イベントカウンターの要件

```csharp
public void Record(string eventName)
{
    // 1秒間に数千回呼ばれる
    // 複数スレッドから同時アクセス
    // サーバー負荷の指標として使用
}
```

**問い：** あなたならどう実装しますか？

---

## スライド3: まずはスレッドセーフでない実装（30秒）

### ❌ MethodCounter_NotThreadSafe

```csharp
private Dictionary<string, int> _counts = new();

public void Record(string methodName)
{
    if (_counts.ContainsKey(methodName))
        _counts[methodName]++;  // ← 複数スレッドで例外！
    else
        _counts[methodName] = 1;
}
```

**結果：** 
- 💥 InvalidOperationException
- 💥 カウントが不正確
- 💥 データ構造が破損

---

## スライド4: Lockで解決...でも遅い（40秒）

### ✅ MethodCounter_WithLock

```csharp
private readonly object _lock = new();
private Dictionary<string, int> _counts = new();

public void Record(string methodName)
{
    lock (_lock)  // ← ここがボトルネック！
    {
        if (_counts.ContainsKey(methodName))
            _counts[methodName]++;
        else
            _counts[methodName] = 1;
    }
}
```

**結果：** 
- ✅ 100%正確・安全
- ❌ スレッドが渋滞（1秒数千回の処理に耐えられない）

---

## スライド5: トレードオフの決断（50秒）

### 設計の割り切り

```
キュー交換のタイミング図：
Thread1: ----[参照取得]--[Enqueue]----
Thread2: ----------[Exchange!]---------
         　　　　　　　↑
         　　　この瞬間の書き込みは消える可能性
```

**仕様として許容する理由：**
- 「10万回」が「9万9900回」になっても負荷判定には影響なし
- パフォーマンス向上のメリットが誤差のデメリットを上回る

---

## スライド6: トレードオフの決断（50秒）

### 設計の割り切り

```
キュー交換のタイミング図：
Thread1: ----[参照取得]--[Enqueue]----
Thread2: ----------[Exchange!]---------
         　　　　　　↑
         　　　この瞬間の書き込みは消える可能性
```

**仕様として許容する理由：**
- 「10万回」が「9万9900回」になっても負荷判定には影響なし
- パフォーマンス向上のメリットが誤差のデメリットを上回る

### なぜLock-free実装が高速なのか？

1. **ConcurrentQueue**: 内部でlock-freeアルゴリズム使用
2. **Interlocked.Exchange**: CPU命令レベルでアトミック
3. **並行実行可能**: スレッドが待機する必要なし

---

## スライド7: 実装の技術要素（30秒）

## スライド8: 設計思想のまとめ（40秒）

### 実践的マルチスレッド設計の極意

**1. 要件を正しく理解する**
- 本当に100%の正確性が必要か？

**2. 適切な技術を選択する**
- lock → 簡単だが遅い
- lock-free → 高速だが複雑

**3. トレードオフを明文化する**
- コメントで設計意図を残す
- 将来の保守者への配慮

---

## スライド9: 次のステップ（20秒）

## スライド9: 次のステップ（20秒）

### さらに学ぶために

- **Task/async-await**: より高レベルな並行処理
- **Channel<T>**: Producer-Consumerパターンの実装
- **ベンチマーク**: BenchmarkDotNetで実測

**質問・議論大歓迎！**

GitHub: [your-repo-link]  
Twitter: [@your-handle]

---

## 発表者メモ

### タイムライン（5分）
- 0:00-0:20 タイトル・自己紹介
- 0:20-0:50 問題提起（スライド2）
- 0:50-1:20 スレッドセーフでない例（スライド3）
- 1:20-2:00 Lock版の問題（スライド4）
- 2:00-3:00 Lock-free設計（スライド5）
- 3:00-3:50 トレードオフの説明（スライド6）
- 3:50-4:20 技術要素（スライド7）
- 4:20-4:50 まとめ（スライド8）
- 4:50-5:00 次のステップ（スライド9）

### ポイント
- コード例は最小限に（読みやすさ重視）
- 図解を活用（特にスライド5）
- 「なぜ」を中心に説明
- 実践的な判断基準を提供